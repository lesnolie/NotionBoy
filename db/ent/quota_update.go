// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"notionboy/db/ent/predicate"
	"notionboy/db/ent/quota"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// QuotaUpdate is the builder for updating Quota entities.
type QuotaUpdate struct {
	config
	hooks    []Hook
	mutation *QuotaMutation
}

// Where appends a list predicates to the QuotaUpdate builder.
func (qu *QuotaUpdate) Where(ps ...predicate.Quota) *QuotaUpdate {
	qu.mutation.Where(ps...)
	return qu
}

// SetUpdatedAt sets the "updated_at" field.
func (qu *QuotaUpdate) SetUpdatedAt(t time.Time) *QuotaUpdate {
	qu.mutation.SetUpdatedAt(t)
	return qu
}

// SetDeleted sets the "deleted" field.
func (qu *QuotaUpdate) SetDeleted(b bool) *QuotaUpdate {
	qu.mutation.SetDeleted(b)
	return qu
}

// SetNillableDeleted sets the "deleted" field if the given value is not nil.
func (qu *QuotaUpdate) SetNillableDeleted(b *bool) *QuotaUpdate {
	if b != nil {
		qu.SetDeleted(*b)
	}
	return qu
}

// SetUserID sets the "user_id" field.
func (qu *QuotaUpdate) SetUserID(i int) *QuotaUpdate {
	qu.mutation.ResetUserID()
	qu.mutation.SetUserID(i)
	return qu
}

// AddUserID adds i to the "user_id" field.
func (qu *QuotaUpdate) AddUserID(i int) *QuotaUpdate {
	qu.mutation.AddUserID(i)
	return qu
}

// SetCategory sets the "category" field.
func (qu *QuotaUpdate) SetCategory(q quota.Category) *QuotaUpdate {
	qu.mutation.SetCategory(q)
	return qu
}

// SetDaily sets the "daily" field.
func (qu *QuotaUpdate) SetDaily(i int) *QuotaUpdate {
	qu.mutation.ResetDaily()
	qu.mutation.SetDaily(i)
	return qu
}

// SetNillableDaily sets the "daily" field if the given value is not nil.
func (qu *QuotaUpdate) SetNillableDaily(i *int) *QuotaUpdate {
	if i != nil {
		qu.SetDaily(*i)
	}
	return qu
}

// AddDaily adds i to the "daily" field.
func (qu *QuotaUpdate) AddDaily(i int) *QuotaUpdate {
	qu.mutation.AddDaily(i)
	return qu
}

// ClearDaily clears the value of the "daily" field.
func (qu *QuotaUpdate) ClearDaily() *QuotaUpdate {
	qu.mutation.ClearDaily()
	return qu
}

// SetMonthly sets the "monthly" field.
func (qu *QuotaUpdate) SetMonthly(i int) *QuotaUpdate {
	qu.mutation.ResetMonthly()
	qu.mutation.SetMonthly(i)
	return qu
}

// SetNillableMonthly sets the "monthly" field if the given value is not nil.
func (qu *QuotaUpdate) SetNillableMonthly(i *int) *QuotaUpdate {
	if i != nil {
		qu.SetMonthly(*i)
	}
	return qu
}

// AddMonthly adds i to the "monthly" field.
func (qu *QuotaUpdate) AddMonthly(i int) *QuotaUpdate {
	qu.mutation.AddMonthly(i)
	return qu
}

// ClearMonthly clears the value of the "monthly" field.
func (qu *QuotaUpdate) ClearMonthly() *QuotaUpdate {
	qu.mutation.ClearMonthly()
	return qu
}

// SetYearly sets the "yearly" field.
func (qu *QuotaUpdate) SetYearly(i int) *QuotaUpdate {
	qu.mutation.ResetYearly()
	qu.mutation.SetYearly(i)
	return qu
}

// SetNillableYearly sets the "yearly" field if the given value is not nil.
func (qu *QuotaUpdate) SetNillableYearly(i *int) *QuotaUpdate {
	if i != nil {
		qu.SetYearly(*i)
	}
	return qu
}

// AddYearly adds i to the "yearly" field.
func (qu *QuotaUpdate) AddYearly(i int) *QuotaUpdate {
	qu.mutation.AddYearly(i)
	return qu
}

// ClearYearly clears the value of the "yearly" field.
func (qu *QuotaUpdate) ClearYearly() *QuotaUpdate {
	qu.mutation.ClearYearly()
	return qu
}

// SetDailyUsed sets the "daily_used" field.
func (qu *QuotaUpdate) SetDailyUsed(i int) *QuotaUpdate {
	qu.mutation.ResetDailyUsed()
	qu.mutation.SetDailyUsed(i)
	return qu
}

// SetNillableDailyUsed sets the "daily_used" field if the given value is not nil.
func (qu *QuotaUpdate) SetNillableDailyUsed(i *int) *QuotaUpdate {
	if i != nil {
		qu.SetDailyUsed(*i)
	}
	return qu
}

// AddDailyUsed adds i to the "daily_used" field.
func (qu *QuotaUpdate) AddDailyUsed(i int) *QuotaUpdate {
	qu.mutation.AddDailyUsed(i)
	return qu
}

// ClearDailyUsed clears the value of the "daily_used" field.
func (qu *QuotaUpdate) ClearDailyUsed() *QuotaUpdate {
	qu.mutation.ClearDailyUsed()
	return qu
}

// SetMonthlyUsed sets the "monthly_used" field.
func (qu *QuotaUpdate) SetMonthlyUsed(i int) *QuotaUpdate {
	qu.mutation.ResetMonthlyUsed()
	qu.mutation.SetMonthlyUsed(i)
	return qu
}

// SetNillableMonthlyUsed sets the "monthly_used" field if the given value is not nil.
func (qu *QuotaUpdate) SetNillableMonthlyUsed(i *int) *QuotaUpdate {
	if i != nil {
		qu.SetMonthlyUsed(*i)
	}
	return qu
}

// AddMonthlyUsed adds i to the "monthly_used" field.
func (qu *QuotaUpdate) AddMonthlyUsed(i int) *QuotaUpdate {
	qu.mutation.AddMonthlyUsed(i)
	return qu
}

// ClearMonthlyUsed clears the value of the "monthly_used" field.
func (qu *QuotaUpdate) ClearMonthlyUsed() *QuotaUpdate {
	qu.mutation.ClearMonthlyUsed()
	return qu
}

// SetYearlyUsed sets the "yearly_used" field.
func (qu *QuotaUpdate) SetYearlyUsed(i int) *QuotaUpdate {
	qu.mutation.ResetYearlyUsed()
	qu.mutation.SetYearlyUsed(i)
	return qu
}

// SetNillableYearlyUsed sets the "yearly_used" field if the given value is not nil.
func (qu *QuotaUpdate) SetNillableYearlyUsed(i *int) *QuotaUpdate {
	if i != nil {
		qu.SetYearlyUsed(*i)
	}
	return qu
}

// AddYearlyUsed adds i to the "yearly_used" field.
func (qu *QuotaUpdate) AddYearlyUsed(i int) *QuotaUpdate {
	qu.mutation.AddYearlyUsed(i)
	return qu
}

// ClearYearlyUsed clears the value of the "yearly_used" field.
func (qu *QuotaUpdate) ClearYearlyUsed() *QuotaUpdate {
	qu.mutation.ClearYearlyUsed()
	return qu
}

// Mutation returns the QuotaMutation object of the builder.
func (qu *QuotaUpdate) Mutation() *QuotaMutation {
	return qu.mutation
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (qu *QuotaUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	qu.defaults()
	if len(qu.hooks) == 0 {
		if err = qu.check(); err != nil {
			return 0, err
		}
		affected, err = qu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*QuotaMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = qu.check(); err != nil {
				return 0, err
			}
			qu.mutation = mutation
			affected, err = qu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(qu.hooks) - 1; i >= 0; i-- {
			if qu.hooks[i] == nil {
				return 0, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = qu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, qu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (qu *QuotaUpdate) SaveX(ctx context.Context) int {
	affected, err := qu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (qu *QuotaUpdate) Exec(ctx context.Context) error {
	_, err := qu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (qu *QuotaUpdate) ExecX(ctx context.Context) {
	if err := qu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (qu *QuotaUpdate) defaults() {
	if _, ok := qu.mutation.UpdatedAt(); !ok {
		v := quota.UpdateDefaultUpdatedAt()
		qu.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (qu *QuotaUpdate) check() error {
	if v, ok := qu.mutation.Category(); ok {
		if err := quota.CategoryValidator(v); err != nil {
			return &ValidationError{Name: "category", err: fmt.Errorf(`ent: validator failed for field "Quota.category": %w`, err)}
		}
	}
	return nil
}

func (qu *QuotaUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   quota.Table,
			Columns: quota.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: quota.FieldID,
			},
		},
	}
	if ps := qu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := qu.mutation.UpdatedAt(); ok {
		_spec.SetField(quota.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := qu.mutation.Deleted(); ok {
		_spec.SetField(quota.FieldDeleted, field.TypeBool, value)
	}
	if value, ok := qu.mutation.UserID(); ok {
		_spec.SetField(quota.FieldUserID, field.TypeInt, value)
	}
	if value, ok := qu.mutation.AddedUserID(); ok {
		_spec.AddField(quota.FieldUserID, field.TypeInt, value)
	}
	if value, ok := qu.mutation.Category(); ok {
		_spec.SetField(quota.FieldCategory, field.TypeEnum, value)
	}
	if value, ok := qu.mutation.Daily(); ok {
		_spec.SetField(quota.FieldDaily, field.TypeInt, value)
	}
	if value, ok := qu.mutation.AddedDaily(); ok {
		_spec.AddField(quota.FieldDaily, field.TypeInt, value)
	}
	if qu.mutation.DailyCleared() {
		_spec.ClearField(quota.FieldDaily, field.TypeInt)
	}
	if value, ok := qu.mutation.Monthly(); ok {
		_spec.SetField(quota.FieldMonthly, field.TypeInt, value)
	}
	if value, ok := qu.mutation.AddedMonthly(); ok {
		_spec.AddField(quota.FieldMonthly, field.TypeInt, value)
	}
	if qu.mutation.MonthlyCleared() {
		_spec.ClearField(quota.FieldMonthly, field.TypeInt)
	}
	if value, ok := qu.mutation.Yearly(); ok {
		_spec.SetField(quota.FieldYearly, field.TypeInt, value)
	}
	if value, ok := qu.mutation.AddedYearly(); ok {
		_spec.AddField(quota.FieldYearly, field.TypeInt, value)
	}
	if qu.mutation.YearlyCleared() {
		_spec.ClearField(quota.FieldYearly, field.TypeInt)
	}
	if value, ok := qu.mutation.DailyUsed(); ok {
		_spec.SetField(quota.FieldDailyUsed, field.TypeInt, value)
	}
	if value, ok := qu.mutation.AddedDailyUsed(); ok {
		_spec.AddField(quota.FieldDailyUsed, field.TypeInt, value)
	}
	if qu.mutation.DailyUsedCleared() {
		_spec.ClearField(quota.FieldDailyUsed, field.TypeInt)
	}
	if value, ok := qu.mutation.MonthlyUsed(); ok {
		_spec.SetField(quota.FieldMonthlyUsed, field.TypeInt, value)
	}
	if value, ok := qu.mutation.AddedMonthlyUsed(); ok {
		_spec.AddField(quota.FieldMonthlyUsed, field.TypeInt, value)
	}
	if qu.mutation.MonthlyUsedCleared() {
		_spec.ClearField(quota.FieldMonthlyUsed, field.TypeInt)
	}
	if value, ok := qu.mutation.YearlyUsed(); ok {
		_spec.SetField(quota.FieldYearlyUsed, field.TypeInt, value)
	}
	if value, ok := qu.mutation.AddedYearlyUsed(); ok {
		_spec.AddField(quota.FieldYearlyUsed, field.TypeInt, value)
	}
	if qu.mutation.YearlyUsedCleared() {
		_spec.ClearField(quota.FieldYearlyUsed, field.TypeInt)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, qu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{quota.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	return n, nil
}

// QuotaUpdateOne is the builder for updating a single Quota entity.
type QuotaUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *QuotaMutation
}

// SetUpdatedAt sets the "updated_at" field.
func (quo *QuotaUpdateOne) SetUpdatedAt(t time.Time) *QuotaUpdateOne {
	quo.mutation.SetUpdatedAt(t)
	return quo
}

// SetDeleted sets the "deleted" field.
func (quo *QuotaUpdateOne) SetDeleted(b bool) *QuotaUpdateOne {
	quo.mutation.SetDeleted(b)
	return quo
}

// SetNillableDeleted sets the "deleted" field if the given value is not nil.
func (quo *QuotaUpdateOne) SetNillableDeleted(b *bool) *QuotaUpdateOne {
	if b != nil {
		quo.SetDeleted(*b)
	}
	return quo
}

// SetUserID sets the "user_id" field.
func (quo *QuotaUpdateOne) SetUserID(i int) *QuotaUpdateOne {
	quo.mutation.ResetUserID()
	quo.mutation.SetUserID(i)
	return quo
}

// AddUserID adds i to the "user_id" field.
func (quo *QuotaUpdateOne) AddUserID(i int) *QuotaUpdateOne {
	quo.mutation.AddUserID(i)
	return quo
}

// SetCategory sets the "category" field.
func (quo *QuotaUpdateOne) SetCategory(q quota.Category) *QuotaUpdateOne {
	quo.mutation.SetCategory(q)
	return quo
}

// SetDaily sets the "daily" field.
func (quo *QuotaUpdateOne) SetDaily(i int) *QuotaUpdateOne {
	quo.mutation.ResetDaily()
	quo.mutation.SetDaily(i)
	return quo
}

// SetNillableDaily sets the "daily" field if the given value is not nil.
func (quo *QuotaUpdateOne) SetNillableDaily(i *int) *QuotaUpdateOne {
	if i != nil {
		quo.SetDaily(*i)
	}
	return quo
}

// AddDaily adds i to the "daily" field.
func (quo *QuotaUpdateOne) AddDaily(i int) *QuotaUpdateOne {
	quo.mutation.AddDaily(i)
	return quo
}

// ClearDaily clears the value of the "daily" field.
func (quo *QuotaUpdateOne) ClearDaily() *QuotaUpdateOne {
	quo.mutation.ClearDaily()
	return quo
}

// SetMonthly sets the "monthly" field.
func (quo *QuotaUpdateOne) SetMonthly(i int) *QuotaUpdateOne {
	quo.mutation.ResetMonthly()
	quo.mutation.SetMonthly(i)
	return quo
}

// SetNillableMonthly sets the "monthly" field if the given value is not nil.
func (quo *QuotaUpdateOne) SetNillableMonthly(i *int) *QuotaUpdateOne {
	if i != nil {
		quo.SetMonthly(*i)
	}
	return quo
}

// AddMonthly adds i to the "monthly" field.
func (quo *QuotaUpdateOne) AddMonthly(i int) *QuotaUpdateOne {
	quo.mutation.AddMonthly(i)
	return quo
}

// ClearMonthly clears the value of the "monthly" field.
func (quo *QuotaUpdateOne) ClearMonthly() *QuotaUpdateOne {
	quo.mutation.ClearMonthly()
	return quo
}

// SetYearly sets the "yearly" field.
func (quo *QuotaUpdateOne) SetYearly(i int) *QuotaUpdateOne {
	quo.mutation.ResetYearly()
	quo.mutation.SetYearly(i)
	return quo
}

// SetNillableYearly sets the "yearly" field if the given value is not nil.
func (quo *QuotaUpdateOne) SetNillableYearly(i *int) *QuotaUpdateOne {
	if i != nil {
		quo.SetYearly(*i)
	}
	return quo
}

// AddYearly adds i to the "yearly" field.
func (quo *QuotaUpdateOne) AddYearly(i int) *QuotaUpdateOne {
	quo.mutation.AddYearly(i)
	return quo
}

// ClearYearly clears the value of the "yearly" field.
func (quo *QuotaUpdateOne) ClearYearly() *QuotaUpdateOne {
	quo.mutation.ClearYearly()
	return quo
}

// SetDailyUsed sets the "daily_used" field.
func (quo *QuotaUpdateOne) SetDailyUsed(i int) *QuotaUpdateOne {
	quo.mutation.ResetDailyUsed()
	quo.mutation.SetDailyUsed(i)
	return quo
}

// SetNillableDailyUsed sets the "daily_used" field if the given value is not nil.
func (quo *QuotaUpdateOne) SetNillableDailyUsed(i *int) *QuotaUpdateOne {
	if i != nil {
		quo.SetDailyUsed(*i)
	}
	return quo
}

// AddDailyUsed adds i to the "daily_used" field.
func (quo *QuotaUpdateOne) AddDailyUsed(i int) *QuotaUpdateOne {
	quo.mutation.AddDailyUsed(i)
	return quo
}

// ClearDailyUsed clears the value of the "daily_used" field.
func (quo *QuotaUpdateOne) ClearDailyUsed() *QuotaUpdateOne {
	quo.mutation.ClearDailyUsed()
	return quo
}

// SetMonthlyUsed sets the "monthly_used" field.
func (quo *QuotaUpdateOne) SetMonthlyUsed(i int) *QuotaUpdateOne {
	quo.mutation.ResetMonthlyUsed()
	quo.mutation.SetMonthlyUsed(i)
	return quo
}

// SetNillableMonthlyUsed sets the "monthly_used" field if the given value is not nil.
func (quo *QuotaUpdateOne) SetNillableMonthlyUsed(i *int) *QuotaUpdateOne {
	if i != nil {
		quo.SetMonthlyUsed(*i)
	}
	return quo
}

// AddMonthlyUsed adds i to the "monthly_used" field.
func (quo *QuotaUpdateOne) AddMonthlyUsed(i int) *QuotaUpdateOne {
	quo.mutation.AddMonthlyUsed(i)
	return quo
}

// ClearMonthlyUsed clears the value of the "monthly_used" field.
func (quo *QuotaUpdateOne) ClearMonthlyUsed() *QuotaUpdateOne {
	quo.mutation.ClearMonthlyUsed()
	return quo
}

// SetYearlyUsed sets the "yearly_used" field.
func (quo *QuotaUpdateOne) SetYearlyUsed(i int) *QuotaUpdateOne {
	quo.mutation.ResetYearlyUsed()
	quo.mutation.SetYearlyUsed(i)
	return quo
}

// SetNillableYearlyUsed sets the "yearly_used" field if the given value is not nil.
func (quo *QuotaUpdateOne) SetNillableYearlyUsed(i *int) *QuotaUpdateOne {
	if i != nil {
		quo.SetYearlyUsed(*i)
	}
	return quo
}

// AddYearlyUsed adds i to the "yearly_used" field.
func (quo *QuotaUpdateOne) AddYearlyUsed(i int) *QuotaUpdateOne {
	quo.mutation.AddYearlyUsed(i)
	return quo
}

// ClearYearlyUsed clears the value of the "yearly_used" field.
func (quo *QuotaUpdateOne) ClearYearlyUsed() *QuotaUpdateOne {
	quo.mutation.ClearYearlyUsed()
	return quo
}

// Mutation returns the QuotaMutation object of the builder.
func (quo *QuotaUpdateOne) Mutation() *QuotaMutation {
	return quo.mutation
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (quo *QuotaUpdateOne) Select(field string, fields ...string) *QuotaUpdateOne {
	quo.fields = append([]string{field}, fields...)
	return quo
}

// Save executes the query and returns the updated Quota entity.
func (quo *QuotaUpdateOne) Save(ctx context.Context) (*Quota, error) {
	var (
		err  error
		node *Quota
	)
	quo.defaults()
	if len(quo.hooks) == 0 {
		if err = quo.check(); err != nil {
			return nil, err
		}
		node, err = quo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*QuotaMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = quo.check(); err != nil {
				return nil, err
			}
			quo.mutation = mutation
			node, err = quo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(quo.hooks) - 1; i >= 0; i-- {
			if quo.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = quo.hooks[i](mut)
		}
		v, err := mut.Mutate(ctx, quo.mutation)
		if err != nil {
			return nil, err
		}
		nv, ok := v.(*Quota)
		if !ok {
			return nil, fmt.Errorf("unexpected node type %T returned from QuotaMutation", v)
		}
		node = nv
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (quo *QuotaUpdateOne) SaveX(ctx context.Context) *Quota {
	node, err := quo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (quo *QuotaUpdateOne) Exec(ctx context.Context) error {
	_, err := quo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (quo *QuotaUpdateOne) ExecX(ctx context.Context) {
	if err := quo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (quo *QuotaUpdateOne) defaults() {
	if _, ok := quo.mutation.UpdatedAt(); !ok {
		v := quota.UpdateDefaultUpdatedAt()
		quo.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (quo *QuotaUpdateOne) check() error {
	if v, ok := quo.mutation.Category(); ok {
		if err := quota.CategoryValidator(v); err != nil {
			return &ValidationError{Name: "category", err: fmt.Errorf(`ent: validator failed for field "Quota.category": %w`, err)}
		}
	}
	return nil
}

func (quo *QuotaUpdateOne) sqlSave(ctx context.Context) (_node *Quota, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   quota.Table,
			Columns: quota.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeInt,
				Column: quota.FieldID,
			},
		},
	}
	id, ok := quo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Quota.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := quo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, quota.FieldID)
		for _, f := range fields {
			if !quota.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != quota.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := quo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := quo.mutation.UpdatedAt(); ok {
		_spec.SetField(quota.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := quo.mutation.Deleted(); ok {
		_spec.SetField(quota.FieldDeleted, field.TypeBool, value)
	}
	if value, ok := quo.mutation.UserID(); ok {
		_spec.SetField(quota.FieldUserID, field.TypeInt, value)
	}
	if value, ok := quo.mutation.AddedUserID(); ok {
		_spec.AddField(quota.FieldUserID, field.TypeInt, value)
	}
	if value, ok := quo.mutation.Category(); ok {
		_spec.SetField(quota.FieldCategory, field.TypeEnum, value)
	}
	if value, ok := quo.mutation.Daily(); ok {
		_spec.SetField(quota.FieldDaily, field.TypeInt, value)
	}
	if value, ok := quo.mutation.AddedDaily(); ok {
		_spec.AddField(quota.FieldDaily, field.TypeInt, value)
	}
	if quo.mutation.DailyCleared() {
		_spec.ClearField(quota.FieldDaily, field.TypeInt)
	}
	if value, ok := quo.mutation.Monthly(); ok {
		_spec.SetField(quota.FieldMonthly, field.TypeInt, value)
	}
	if value, ok := quo.mutation.AddedMonthly(); ok {
		_spec.AddField(quota.FieldMonthly, field.TypeInt, value)
	}
	if quo.mutation.MonthlyCleared() {
		_spec.ClearField(quota.FieldMonthly, field.TypeInt)
	}
	if value, ok := quo.mutation.Yearly(); ok {
		_spec.SetField(quota.FieldYearly, field.TypeInt, value)
	}
	if value, ok := quo.mutation.AddedYearly(); ok {
		_spec.AddField(quota.FieldYearly, field.TypeInt, value)
	}
	if quo.mutation.YearlyCleared() {
		_spec.ClearField(quota.FieldYearly, field.TypeInt)
	}
	if value, ok := quo.mutation.DailyUsed(); ok {
		_spec.SetField(quota.FieldDailyUsed, field.TypeInt, value)
	}
	if value, ok := quo.mutation.AddedDailyUsed(); ok {
		_spec.AddField(quota.FieldDailyUsed, field.TypeInt, value)
	}
	if quo.mutation.DailyUsedCleared() {
		_spec.ClearField(quota.FieldDailyUsed, field.TypeInt)
	}
	if value, ok := quo.mutation.MonthlyUsed(); ok {
		_spec.SetField(quota.FieldMonthlyUsed, field.TypeInt, value)
	}
	if value, ok := quo.mutation.AddedMonthlyUsed(); ok {
		_spec.AddField(quota.FieldMonthlyUsed, field.TypeInt, value)
	}
	if quo.mutation.MonthlyUsedCleared() {
		_spec.ClearField(quota.FieldMonthlyUsed, field.TypeInt)
	}
	if value, ok := quo.mutation.YearlyUsed(); ok {
		_spec.SetField(quota.FieldYearlyUsed, field.TypeInt, value)
	}
	if value, ok := quo.mutation.AddedYearlyUsed(); ok {
		_spec.AddField(quota.FieldYearlyUsed, field.TypeInt, value)
	}
	if quo.mutation.YearlyUsedCleared() {
		_spec.ClearField(quota.FieldYearlyUsed, field.TypeInt)
	}
	_node = &Quota{config: quo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, quo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{quota.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	return _node, nil
}
